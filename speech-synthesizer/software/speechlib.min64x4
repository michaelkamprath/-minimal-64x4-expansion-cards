; SpeechLib for Minimal 64x4
;
; To be used with the TMS5220C Speech Synthesizer expansion card.
;
#require "slu4-min64x4-asm >= 1.1.0"

SPEECH_COMMAND_REG     = $FEC0
SPEECH_STATUS_REG      = $FEC1
SPEECH_BOARD_STATE_REG = $FEC2
SPEECH_RESET_WS_REG    = $FEC3

SPEECH_CMD_SPEAK_EXTERNAL   = b01100000
SPEECH_CMD_RESET            = b11110000

BOARD_STATE_BUSY            = b00000001       ; bit 0
BOARD_STATE_INTERUPT        = b00000010       ; bit 1
BOARD_STATE_READY           = b00000100       ; bit 2

SPEECH_STATUS_TALK          = b10000000
SPEECH_STATUS_BUFFER_LOW    = b01000000
SPEECH_STATUS_BUFFER_EMPTY  = b00100000

; Zero Page Usage
.memzone ZERO_PAGE_APPS
#mute

_speech_buffer_cur_ptr: .2byte 0
_speech_buffer_end_ptr: .2byte 0


#emit
.memzone USER_APPS
.align
; speech_init
;
;   Prepares the TMS5220 for speech
;
;   Arguments
;       None
;
speech_init:
    ; initialize buffer pointers
    miv 0,_speech_buffer_cur_ptr
    miv 0,_speech_buffer_end_ptr
    ; execute the TMS5220 init sequence documented in
    ; P7 of the TMS5220 data sheet
    ;
    ; First, send 9 bytes of all ones
    mib 9,.counter
    phsi $ff
.loop:
    jps _speech_send_cmd_data
    jps _wait_on_speech_board_busy
    nop nop nop nop nop nop
    deb .counter fne .loop              ; decrement counter and loop if zero not set
    phs
    ; now send reset command
    phsi SPEECH_CMD_RESET
    jps _speech_send_cmd_data
    phs
    ; now wait 300 µs
    mib 100,.counter
.wait:
    nop deb .counter fne .wait
    rts
.counter:   .byte 0



; speak_external_buffer
;   Uses Speak External command to synchonously speak data in passed buffer.
;   Function returns when speaking is done.
;
;   Arguments
;       sp+3 : Buffer Start address (2 bytes)
;       sp+5 : Buffer End address (2 bytes)
;
;   Retruns:
;       None
;
;   Uses A and X registers
;
speak_synchronous:
    ; start speech
    phs2s 5+0
    phs2s 3+2
    jps speech_start
    pls2
    pls2
.buffer_loop:
    ; send 8 bytes until buffer done
    ciz 0,_speech_buffer_cur_ptr+0 fne .update_buffer
    ciz 0,_speech_buffer_cur_ptr+1 fne .update_buffer
    fpa .done_talking
.update_buffer:
    jps speech_update_buffer
    fpa .buffer_loop
.done_talking:
    rts



; speech_start
;   Starts the asynchronous speaking process on the TMS5220 witht he passed buffer. Fills the TMS5220
;   FIFO buffer with 16 bytes, then returns. Caller should call speech_update_buffer
;   every 5-10 ms to check in on speech process and update FIFO buffer if needed.
;   Speech completion status can be checked with speech_is_talking.
;
;   If talking is in progress when this function is called, it will wait for talking to
;   complete.
;
;   Arguments]
;       sp+3 : Buffer Start address (2 bytes)
;       sp+5 : Buffer End address (2 bytes)
;
speech_start:
    ; first check if there is already something talking
    ciz 0,_speech_buffer_cur_ptr+0 fne .wait_for_talking
    ciz 0,_speech_buffer_cur_ptr+1 fne .wait_for_talking
    fpa _setup_talking
.wait_for_talking:
    jps speech_get_status
    ani SPEECH_STATUS_TALK cpi 0 fne .wait_for_talking
_setup_talking:
    ; copy buffer pointers
    ms2v 3,_speech_buffer_cur_ptr
    ms2v 5,_speech_buffer_end_ptr
    ; send speak external command
    phsi SPEECH_CMD_SPEAK_EXTERNAL
    jps _speech_send_cmd_data pls
    ; send 16 bytes
    jps _send_8_bytes
    jps _send_8_bytes
    ; and we are done
    rts


; speech_update_buffer
;   Checks to see if there is an ongoing speech operation and send the TMS5220 more data if
;   it is ready to receive it.
;
;   Arguments
;       None
;
speech_update_buffer:
    ; first, check to see if we have a in-progress buffer, signified by a non-zero pointer
    ciz 0,_speech_buffer_cur_ptr+0 fne .wait_buffer_low
    ciz 0,_speech_buffer_cur_ptr+1 fne .wait_buffer_low
    fpa .done
    ; now check if the TMS5220 FIFO buffer is low
.wait_buffer_low:
    ; check to see if talking stopped but we still have buffer left
    jps speech_get_status phs
    ani SPEECH_STATUS_TALK cpi 0 feq .talking_stopped
    pls
    ani SPEECH_STATUS_BUFFER_LOW
    cpi SPEECH_STATUS_BUFFER_LOW fne .done
    ; OK, we need to send 8 more byte
    jps _send_8_bytes
    fpa .done
.talking_stopped:
    ; TODO handle restarting speech on remaining buffer
.buffer_done:
    ; buffer is done. set pointers to null
    miv 0,_speech_buffer_cur_ptr
    miv 0,_speech_buffer_end_ptr
.done:
    rts





.align
; _send_8_bytes
;   Sends the next 8 bytes in the speech buffer. If less than
;   8 bytes left, will send just that.
_send_8_bytes:
    mib 8,.counter
.send_loop:
    ; ennsure buffer is not done
    czz  _speech_buffer_cur_ptr+1,_speech_buffer_end_ptr+1
    fne .wait
    czz _speech_buffer_cur_ptr+0,_speech_buffer_end_ptr+0
    feq .done
    ; wait for board to not be busy, then wait 10 µs
.wait:
    ldb SPEECH_BOARD_STATE_REG          ; get board state
    ani BOARD_STATE_BUSY                ; get the busy bit
    cpi 0 fne .wait                     ; wait until busy bit is off
.send_byte:
    ; send current byte
    ldt _speech_buffer_cur_ptr          ; get byte at current buffer address
    stb SPEECH_COMMAND_REG              ; send the byte
    ; nop nop nop nop
    ; adjust current ptr and counter
    inv _speech_buffer_cur_ptr          ; increment buffer pointer
    deb .counter fne .send_loop
.done:
    rts
.counter:   .byte 0


; _wait_on_speech_board_busy
;       returns when the speech board is not busy
;
;       Arguments
;           None
;
_wait_on_speech_board_busy:
.wait:
    ldb SPEECH_BOARD_STATE_REG              ; get board state
    ani BOARD_STATE_BUSY                    ; get the busy bit
    cpi 0 fne .wait                         ; wait until busy bit is off
    rts

; _speech_send_cmd_data
;   sends a single byte to the TMS5220 after waiting for it
;   to become not busy
;
;   Arguments
;       SP+3 - the byte to send to the TMS5220
;
;   Returns
;       none
_speech_send_cmd_data:
    jps _wait_on_speech_board_busy
    lds 3
    stb SPEECH_COMMAND_REG              ; send value to command register
    rts


; speech_get_status
;   fetches the inernal status of the TMS5220C
;
;   Arguments
;       None
;
;   Returns
;       Register A - The TMS5220C status byte
;
speech_get_status:
    ; wait until board is not busy
    jps _wait_on_speech_board_busy
    ; write a byte to the status register initiate a fetch
    mib 1,SPEECH_STATUS_REG
    ; now wait until TMS5220 is not busy
    jps _wait_on_speech_board_busy
    ; and fetch the status
    ldb SPEECH_STATUS_REG
    rts
